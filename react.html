<!doctype html>
<html>
<head>
  <title>react</title><meta charset = "utf-8"><link rel="stylesheet" href="style.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script><script src="colors.js"></script>
</head>
<body>
  <h1>REACT</h1>
  <div id="grid">
    <div id="list">
      <h3><a href="index.html">Frontend</a></h3>
      <ul>
        <li><a href = "html.html" title="CSS X">0. HTML舊</a></li>
        <li><a href = "html_designed.html" title="CSS O">1. HTML</a></li>
        <li><a href = "css.html">2. CSS</a></li>
        <li><a href = "javascript.html">3. javascript</a></li>
        <li><a href = "react.html" id = "now">4. react</a></li>
      </ul>
    </div>
    <div>
      <p>
        <span class="subT">리액트</span><br><br>
        리액트의 컴포넌트 기능 > 가독성, 재사용성, 유지보수를 제공<br>
        개발 환경 세팅<br>
        온라인 플레이그라운드 : 컴퓨터에 세팅을 다 하는 게 아니라 온라인 상에서 리액트 어플리케이션을 구현해볼 수 있다.<br>
        add react to website : 부분적으로 리액트 기능 추가, 초급 사용자에게는 조금 어려울 수도 있다.<br>
        create a new react app : 목표를 달성하기 위한 여러 개발 환경과 도구를 잘 모아서 한방에 제공해주는 툴 체인이라고 한다.<br>
      </p>
      <p>
        <span class="subT">javascript 수정하는 법</span><br><br>
        시작은 npm run start
        react-app 폴더 내 index.html에서 기억할 것은 id가 root인 점이다.<br>
        리엑트로 컴포넌트를 만들때, 컴포넌트들이 아이디가 root인 태그 안쪽에 저장된다.<br>
        src되어있는 디렉토리 안에 있는 파일을 수정하면 컴포넌트를 만들 수 있다.<br>
        진입 파일은 index.js 파일, 여기에서 주목해야할 부분은 document.getElementById('root');<br>
        아이디가 루트인 태그를 선택한다는 내용<br> 위의 코드의 root가 index.html의 id="root"이 부분이다.<br>
        App @@가 컴포넌트<br>
        개발할 때는 app.js라는 코드의 &ltheader>코드부터를 수정하면 된다. 가장 바깥 쪽의 태그는 남겨줘야한다.<br>
        저장할 때마다 자동으로 리로드를 해준다.<br>
      </p>
      <p>
        <span class="subT">css 수정하는 법</span><br><br>
        create react app의 지배하에서 어떻게 수정하는가<br>
        @@@.css파일을 내부를 수정하면 된다.<br>
      </p>
      <p>
        <span class="subT">배포하는 법</span><br><br>
        리액트가 개발의 편의성을 위해 기능을 추가한 상태라 파일의 무게가 좀 무겁다<br>
        혼자 쓸 때는 상관 없는데 배포할 때는 조금 문제가 생긴다.<br>
        npm run build엔터는 이전에는 없었던 build라는 디렉토리가 추가된다.<br>
        그 결과를 보면 꽤나 빡빡하게 생긴 파일이 있는 것을 볼 수 있다. 불필요한 정보(공백 등)을 제거했기 때문<br>
        그러므로 실제 서비스할 때는 build 폴더 안에 있는 것을 쓰면 된다.<br>
        npx serve -s build하면 build를 루트로 해서 웹서버를 한 번 연다(?)는 의미가 된다<br>
      </p>
      <p>
        <span class="subT">컴포넌트 만들기</span><br><br>
        react가 가지고 있는 Component 클래스를 상속하여 만든다.<br>
        render()라는 함수가 반드시 있어야함<br>
        하나의 최상위 태그만 가지고 있어야함<br>
        App 내의 Subject태그는 리액트가 클래스 내부의 리턴 내용으로 바꿔준다<br>
        그리고 저 클래스는 유사 자바스크립트다. 진짜는 아니다.<br>
        페이스북에서 만든 언어 jsx, 이 언어로 만드면 크리에이트 리액트 앱이 알아서 컨버팅해준다.<br>
      </p>
      <p>
        <span class="subT">컴포넌트</span><br><br>
        만들기<br>
        태그 - 이름도 있고, 속성도 있다.<br>
        이름은 공통점이고, 속성은 다른점이다.<br>
        &ltComponent props_name="props_value"><br>
        {this.props.name} : 태그의 속성처럼 name="나나"라고 주면 이 값을 가져온다.<br>
        검사창에서 react 탭에 들어가면 컴포넌트들을 확인할 수 있다.<br>
        <br>분리하기<br>
        import React, {Component} from 'react';<br>
        이건 꼭 추가해주기. 각각의 컴포넌트를 js파일로 만들고 App.js에서 import 해주면된다.<br>
      </p>
      <p>
        <span class="subT">state</span><br><br>
        props : 사용자가 컴포넌트를 조작하는 장치<br>
        state : props의 값에 따라 내부 구현에 필요한 데이터, 내부적 조작장치라고 보면 된다<br>
        컴포넌트가 실행될 때 constructor 안의 코드는 render보다 먼저 실행되어 초기화하는데 사용<br>
        초기화가 끝나면 this.state={}를 통해 state를 초기화<br>
        음... 복잡하다.<br>
        이 내용을 적용하고 싶다면 {this.state.@@@.$$$}로 접근하면 된다.<br>
        외부에서 알 필요가 없는 내용을 가리고 있다.<br>
        배열로 저장하는 것도 가능하다.<br>
        키 값을 추가해주면 콘솔 창에서 더 이상 오류가 발생하지 않는다.<br>
        
      </p>
      <p>
        <span class="subT">이벤트</span><br><br>
        역동성을 추가해주는 요소이다.<br>
        props나 state에 있는 값이 바뀌면 해당되는 컴포넌트의 렌더 함수가 다시 호출되고, 그 랜더 함수 하위에 있는 컴포넌트들의 각자의 렌더 함수가 각자 호출된다. 그러면 화면이 싹 다시 그려진다.<br>
        조건문을 사용하여 state의 값에 따라 render에서 수행되는 작업이 달라지게 하는 것도 가능하다.<br><br>
        자바 스크립트를 이용하여 state 값을 변경하는 것도 가능하다<br>
        링크를 눌러도 리로드 되지 않도록, 기본적인 동작 방법 막는 방법 이벤트객체.preventDefault();<br>
        코드에 debugger라는 코드를 넣으면 실행을 잠시 멈추고 sources라는 페이지로 이동하여 정보를 보기 쉽게 해준다.<br>
        이벤트가 호출됐을 때 실행되는 함수 안에서는 this 값이 컴퍼넌트 자기 자신을 가리키지 않고 아무 값도 세팅되어 있지 않다. 그렇기에 언디파인드의 스테이트를 읽으려고 해서 안된다고 한다.
        this를 못 찾으면 함수가 끝난 직후에 .bind(this)를 추가해주면된다. 그러면 this는 현재 컴포넌트가 된다.<br>
        state를 유사자바스크립트로 바꿀 때면 this.setState({});를 사용하면 된다. this는 위의 문단을 통해 설정된 상황에서.<br>
        bind 함수<br>
        기본적으로 렌더 함수 안에서 this는 그 컴포넌트 자체를 가리킨다. 근데 .bind()없이 내부의 다른 함수에서 this를 사용하면 this가 undefine 됐다고 뜬다.<br>
        .bind(this)는 강제로 this를 주입한다고 생각하면 된다. this를 쓰는 함수에 .bind(객체) 주면 this가 객체가 된단다.<br>
        state를 직접 변경하면 안 되고 함수를 써야하는 이유<br>
        constructor에서는 값을 직접 변경해도 상관 없다. 하지만 이미 컴포넌트가 생성이 끝난 다음에 동적으로 스테이트 값을 바꿀 때는 직접 할 수 없다. 리액트 몰래 값을 바꿔버린 셈<br>
        함수를 사용해야한다. this.setState();라는 함수에 바꾸고 싶은 값을 객체 형태로 주어야한다.<br><br>
        이벤트 객체의 타겟이라는 속성은 그 이벤트가 발생한 태그를 가리킨다.<br>
        -앞은 접두사, 뒤는 접미사<br><br>
        상위 컴포넌트가 하위를 바꾸려면 props를 통해서,
        하위 컴포넌트에서 상위를 바꾸려면 이벤트를 구현하여 스테이트를 변경하는 방법을 통해서 가능하다.<br>
      </p>
      <p>
        <span class="subT">Create 구현</span><br><br>
        삭제할 때 링크를 거는 건 좀 위험할 수 있다.<br>
        method를 post형태로 하면 url에 노출이 안 된다.<br>
        UI에 하등 필요없는 정보는 굳이 state 값으로 넣지 말고 객체로 넣어도 된다.<br>
        push로 추가하기, concat으로 추가하기<br>
        push는 원본을 바꾼다. concat은 원본을 바꾸지 않는다.<br>
        shouldComponentUpdate 값이 false면 render함수는 호출되지 않는다.<br>
        immutable-js의 명령어를 사용하면 절대 원본은 변하지 않는다.<br>
        지울 때 사용하는 @@.splice(어디부터, 몇개);<br>
      </p>
    </div>
  </body>
</html>
